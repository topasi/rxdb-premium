import{appendToArray as n,flatClone as t,getChangedDocumentsSince as e,getPrimaryFieldOfPrimaryKey as a,getSortComparator as s}from"rxdb/plugins/core";import{merge as r,Subject as i}from"rxjs";import{getShardIndex as c,mergeSortedArray as h,prepareShardingQuery as o}from"./sharding-helper.js";export var RxStorageInstanceSharding=function(){function l(n,e,s,r,c,h){this.changes$=new i,this.storage=n,this.databaseName=e,this.collectionName=s,this.schema=r,this.internals=c,this.options=h,this.primaryPath=a(this.schema.primaryKey),this.internals.shardInstances.forEach(((n,e)=>{n.changeStream().subscribe((n=>{var a=t(n);a.checkpoint={[e]:n.checkpoint},this.changes$.next(a)}))}))}var u=l.prototype;return u.bulkWrite=async function(t,e){for(var a=this.primaryPath,s=this.internals.shardInstances,r=s.length,i=new Array(r).fill(0).map((()=>[])),h=0;h<t.length;++h){var o=t[h],l=o.document[a];i[c(r,l)].push(o)}var u={error:[]};return await Promise.all(i.map(((t,a)=>{if(t.length>0)return s[a].bulkWrite(t,e).then((t=>{n(u.error,t.error)}))}))),u},u.findDocumentsById=async function(t,e){for(var a=this.internals.shardInstances,s=a.length,r=new Array(s).fill(0).map((()=>[])),i=0;i<t.length;++i){var h=t[i];r[c(s,h)].push(h)}var o=[];return await Promise.all(r.map(((t,s)=>{if(t.length>0)return a[s].findDocumentsById(t,e).then((t=>{n(o,t)}))}))),o},u.query=async function(n){var t=o(this.schema,n.query),e=t.originalQuery;e.limit&&e.limit;var a=e.skip?e.skip:0;var r=s(this.schema,t.originalQuery),i=[];return await Promise.all(this.internals.shardInstances.map((async n=>{var e=await n.query(t.parentPreparedQuery);i=h(i,e.documents,r)}))),i=i.slice(a),e.limit&&(i=i.slice(0,e.limit)),{documents:i}},u.count=async function(n){for(var t=o(this.schema,n.query),e=await Promise.all(this.internals.shardInstances.map((async(n,e)=>(await n.count(t.parentPreparedQuery)).count))),a=0,s=e.length;s--;)a+=e[s];return{count:a,mode:"fast"}},u.getChangedDocumentsSince=async function(n,a){for(var s=this.internals.shardInstances,r=a?t(a):{},i=await Promise.all(s.map((async(t,a)=>{var s=r[a];return await e(t,n,s)}))),c=[],h=0,o=0;o<i.length&&h!==n;){var l=i[o],u=l.documents.length;if(h+u<=n)h+=u,c.push({checkpoint:l.checkpoint,documents:l.documents,shardIndex:o});else{var m=n-h,p=await e(s[o],m,r[o]);h+=p.documents.length,c.push({checkpoint:p.checkpoint,documents:p.documents,shardIndex:o})}o++}var d=[];return c.forEach((n=>{d=d.concat(n.documents),r[n.shardIndex]=n.checkpoint})),{documents:d=d.sort(((n,t)=>n._meta.lwt-t._meta.lwt)),checkpoint:r}},u.getAttachmentData=function(n,t,e){var a=c(this.internals.shardInstances.length,n);return this.internals.shardInstances[a].getAttachmentData(n,t,e)},u.changeStream=function(){return this.changes$.asObservable()},u.cleanup=async function(n){return!(await Promise.all(this.internals.shardInstances.map((t=>t.cleanup(n))))).find((n=>!1===n))},u.close=function(){return this.changes$.complete(),Promise.all(this.internals.shardInstances.map((n=>n.close()))).then((()=>{}))},u.remove=function(){return this.changes$.complete(),Promise.all(this.internals.shardInstances.map((n=>n.remove()))).then((()=>{}))},u.conflictResultionTasks=function(){var n=this.internals.shardInstances.map((n=>n.conflictResultionTasks()));return r(...n)},u.resolveConflictResultionTask=function(n){return Promise.all(this.internals.shardInstances.map((t=>t.resolveConflictResultionTask(n)))).then((()=>{}))},l}();