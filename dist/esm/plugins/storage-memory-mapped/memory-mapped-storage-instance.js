import{getPrimaryFieldOfPrimaryKey as t,PROMISE_RESOLVE_VOID as e,createRevision as n,now as i,RXJS_SHARE_REPLAY_DEFAULTS as s,getWrittenDocumentsFromBulkWriteResponse as a,requestIdlePromiseNoQueue as r}from"rxdb/plugins/core";import{filter as o,shareReplay as h}from"rxjs";import{getNextBlockId as l}from"./helper.js";import{cleanupNonCleanedBlocks as c}from"./cleanup.js";export var MemoryMappedRxStorageInstance=function(){function m(n,i,s,a,r,o,h,l){if(this.closed=!1,this.writeQueue=e,this.writeTasks=[],this.storage=n,this.databaseName=i,this.collectionName=s,this.databaseInstanceToken=a,this.schema=r,this.internals=o,this.options=h,this.devMode=l,this.primaryPath=t(this.schema.primaryKey),r.attachments)throw new Error("Attachments are not supported in the memory-mapped storage because storing attachments in memory would have bad performance")}var u=m.prototype;return u.bulkWrite=async function(t,e){var s=this.primaryPath;await this.internals.initDonePromise;var o=this.internals.memoryInstance.bulkWrite(t,e);return this.writeTasks.push(o.then((e=>a(s,t,e)))),this.writeQueue=this.writeQueue.then((async()=>{if(0!==this.writeTasks.length){this.storage.settings.awaitWritePersistence||await r();var t=this.writeTasks;this.writeTasks=[];for(var a=await Promise.all(t),o=[],h=0;h<a.length;h++){var c=a[h];if(0===c.length)return;for(var m=await l(this),u=this.internals.blockMap,w=0;w<c.length;w++){var p=c[w][s];u.set(p,m)}o.push({document:{id:m,c:!1,s:[],d:c,_attachments:{},_deleted:!1,_meta:{lwt:i()},_rev:n(this.databaseInstanceToken)}})}var f=await this.internals.persistentInstancePromise;if(o.length>0){var d=await f.bulkWrite(o,e);if(d.error[0])throw d.error[0]}}})),this.storage.settings.awaitWritePersistence&&await this.writeQueue,o},u.findDocumentsById=async function(t,e){return await this.internals.initDonePromise,this.internals.memoryInstance.findDocumentsById(t,e)},u.query=async function(t){return await this.internals.initDonePromise,await this.internals.memoryInstance.query(t)},u.count=async function(t){return await this.internals.initDonePromise,this.internals.memoryInstance.count(t)},u.getAttachmentData=async function(t,e,n){return await this.internals.initDonePromise,this.internals.memoryInstance.getAttachmentData(t,e,n)},u.changeStream=function(){var t=!1;return this.internals.initDonePromise.then((()=>t=!0)),this.internals.memoryInstance.changeStream().pipe(o((()=>!!t)),h(s))},u.cleanup=async function(t){if(await this.internals.initDonePromise,await c(this))return!1;var[e,n]=await Promise.all([this.internals.memoryInstance.cleanup(t),this.internals.persistentInstancePromise.then((e=>e.cleanup(t)))]);return e&&n},u.close=async function(){await this.internals.initDonePromise,await this.writeQueue,await c(this),this.internals.refCount=this.internals.refCount-1,0===this.internals.refCount&&(this.storage.openInstances.delete(this.internals.cacheKey),await Promise.all([this.internals.memoryInstance.close(),this.internals.persistentInstancePromise.then((t=>t.close()))]),this.internals.leaderElector&&(this.internals.leaderElector.die(),this.internals.leaderElector.broadcastChannel.close()))},u.remove=async function(){await this.internals.initDonePromise,this.storage.openInstances.delete(this.internals.cacheKey),await this.writeQueue,await Promise.all([this.internals.memoryInstance.remove(),this.internals.persistentInstancePromise.then((t=>t.remove()))]),this.internals.leaderElector&&(this.internals.leaderElector.die(),this.internals.leaderElector.broadcastChannel.close())},u.conflictResultionTasks=function(){return this.internals.conflictResultionTasks$.asObservable()},u.resolveConflictResultionTask=function(t){return e},m}();