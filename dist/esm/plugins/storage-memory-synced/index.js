import{replicateRxStorageInstance as e,randomCouchString as t,awaitRxStorageReplicationFirstInSync as n,STORAGE_TOKEN_DOCUMENT_ID as a,flatClone as s,rxStorageInstanceToReplicationHandler as r,INTERNAL_STORE_SCHEMA_TITLE as i,defaultHashSha256 as o,getRxReplicationMetaInstanceSchema as c,getPrimaryFieldOfPrimaryKey as m,RXJS_SHARE_REPLAY_DEFAULTS as h,getWrittenDocumentsFromBulkWriteResponse as d}from"rxdb/plugins/core";import{RX_LOCAL_DOCUMENT_SCHEMA as l}from"rxdb/plugins/local-documents";import{getRxStorageMemory as p}from"rxdb/plugins/storage-memory";import{MemorySyncedRxStorageInstance as g}from"./memory-synced-storage-instance.js";import{filter as u,firstValueFrom as f,Subject as y,shareReplay as I}from"rxjs";import{checkVersion as b}from"../../plugins/shared/version-check.js";import{RXDB_PREMIUM_VERSION as S}from"../shared/rxdb-premium-version.js";var v=p();export var RxStorageMemorySynced=function(){function p(e){this.name="memory-synced",this.rxdbVersion=S,this.firstInstanceTokens={},this.settings=e}return p.prototype.createStorageInstance=async function(p){var S=m(p.schema.primaryKey);b();var w=p.databaseInstanceToken,k=this;if(p.schema.attachments)throw new Error("The memory-synced plugin does not support attachments");if(p.schema.title===i){var x=await this.settings.storage.createStorageInstance(p),T=x.bulkWrite.bind(x);return x.bulkWrite=async function(e,t){var n=await T(e,t),s=d("id",e,n).find((e=>e.id===a));return s&&s.data.instanceToken===w&&(k.firstInstanceTokens[w]=new Set),n},x}if(p.schema.title===l.title)return await this.settings.storage.createStorageInstance(p);var N=s(p);this.settings.keepIndexesOnParent||(N.schema=s(N.schema),N.schema.indexes=[["_meta.lwt",S]]);var j=this.settings.storage.createStorageInstance(N),P=s(p.schema);delete P.encrypted;var z,M=v.createStorageInstance(Object.assign({},Object.assign({},p,{multiInstance:!1,databaseInstanceToken:t(10),schema:P}),{collectionName:p.collectionName+"-memory-synced-"+t(12)})),B=v.createStorageInstance({databaseName:p.databaseName,collectionName:p.collectionName+"-meta-instance"+t(12),schema:c(p.schema,!1),multiInstance:!1,databaseInstanceToken:t(10),options:{},devMode:p.devMode}),[R,O,C]=await Promise.all([j,M,B]),H=new y,W=new y,$=W.pipe(I(h)),D=new Map,E=Promise.all([M,B,j]).then((([n,a,s])=>{var i=(e,n)=>{var a=Symbol(),s=(async()=>{var s={id:t(10),context:n,input:e},r=f($.pipe(u((e=>e.id===s.id))));H.next(s);var i=await r;return D.delete(a),i.output})();return D.set(a,s),s},c=r(s,i,w);return e({identifier:"memorysyncedstorage+"+t(10),pullBatchSize:this.settings.batchSize?this.settings.batchSize:50,pushBatchSize:this.settings.batchSize?this.settings.batchSize:50,replicationHandler:c,conflictHandler:i,forkInstance:n,metaInstance:a,waitBeforePersist:this.settings.waitBeforePersist,hashFunction:o})}));return this.firstInstanceTokens[w]&&!this.firstInstanceTokens[w].has(p.collectionName)?(this.firstInstanceTokens[w].add(p.collectionName),z=M):z=E.then((e=>n(e))),await j,new g(this,p.databaseName,p.collectionName,p.schema,{masterInstance:R,metaInstance:C,forkInstance:await M,initDonePromise:z,replicationStatePromise:E,conflictTasks$:H,resolvedConflictTasks$:W,openConflictResolutions:D},{})},p}();export function getMemorySyncedRxStorage(e){return new RxStorageMemorySynced(e)}export*from"./memory-synced-types.js";export*from"./memory-synced-storage-instance.js";